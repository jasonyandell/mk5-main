# Solver2 Training Data

Perfect-play minimax solutions for Texas 42, generated by the GPU solver in `forge/oracle/`.

Data files are typically stored under `data/shards-standard/` and `data/shards-marginalized/` (gitignored due to size).

## Data Summary

| Metric | Value |
|--------|-------|
| Total states | 8,412,036,886 |
| Total size | 48.8 GB |
| Seeds solved | 100 (seed 0-99) |
| Declaration types | 10 (all types) |
| Files | 305 |

**Generation method (historical note)**: This section describes one earlier campaign setup; the current generator lives under `forge/cli/` and uses the `forge/oracle/` solver.

## File Format

Files are named `seed_{SEED:08d}_decl_{DECL_ID}.parquet` with Snappy compression.

### Schema

| Column | Type | Description |
|--------|------|-------------|
| `state` | int64 | Packed game state (41 bits used) |
| `V` | int8 | Minimax value-to-go: remaining (team0_points − team1_points) from this state |
| `q0`-`q6` | int8 | Q-values: optimal value per move (-128 = illegal) |

### Parquet Metadata

Each file includes `seed` and `decl_id` in the schema metadata.

## Declaration Types

| ID | Name | Description |
|----|------|-------------|
| 0 | blanks | Blanks are trump |
| 1 | ones | Ones are trump |
| 2 | twos | Twos are trump |
| 3 | threes | Threes are trump |
| 4 | fours | Fours are trump |
| 5 | fives | Fives are trump |
| 6 | sixes | Sixes are trump |
| 7 | doubles-trump | Doubles are trump suit |
| 8 | doubles-suit | Doubles rank high in each suit |
| 9 | notrump | No trump suit |

**Current coverage**: All 10 declaration types are represented across 100 seeds (3 random declarations per seed).

## State Encoding (41 bits)

```
Bits 0-6:   remaining[0]  - Player 0 hand bitmask (7 dominoes → 7 bits)
Bits 7-13:  remaining[1]  - Player 1 hand bitmask
Bits 14-20: remaining[2]  - Player 2 hand bitmask
Bits 21-27: remaining[3]  - Player 3 hand bitmask
Bits 28-29: leader        - Who led current trick (0-3)
Bits 30-31: trick_len     - Cards played in current trick (0-3)
Bits 32-34: p0            - First play: local domino index (0-6, or 7=none)
Bits 35-37: p1            - Second play: local domino index
Bits 38-40: p2            - Third play: local domino index
```

**Key insight**: The bitmasks use *local* indices (0-6) into each player's sorted hand, not global domino IDs. The mapping from local index to global domino ID is seed-specific (via `deal_from_seed()`).

## Value Semantics

### V (State Value)
- Range: [-42, +42]
- Units: **point differential to-go** (remaining Team 0 points minus remaining Team 1 points from this state)
- Positive: Team 0 (players 0,2) is advantaged from here
- Negative: Team 1 (players 1,3) is advantaged from here
- Terminal: `V = 0` (no remaining points)

**Conversion (root / full-hand only)**: At the initial state (before any trick points are scored),
`team0_final_points = (42 + V) / 2` and `team1_final_points = (42 - V) / 2`.

For mid-hand states, this conversion requires also tracking the already-scored differential, which is not encoded in
`state`.

### Q-values (q0-q6)
- Each `q[i]` is the resulting V after playing local domino i (i.e., Q*(s, action_i))
- `-128` sentinel indicates the move is illegal
- Relationship to V:
  - Team 0 to play: `V = max(legal q)`
  - Team 1 to play: `V = min(legal q)`

## Usage for Training

### Loading Data

```python
import pandas as pd

df = pd.read_parquet('data/solver2/seed_00000000_decl_0.parquet')
print(f"States: {len(df):,}")  # 7,607,411 states
```

### Extracting Features

```python
# Decode remaining hands
remaining = []
for i in range(4):
    remaining.append((df['state'] >> (i * 7)) & 0x7F)

# Decode trick state
leader = (df['state'] >> 28) & 0x3
trick_len = (df['state'] >> 30) & 0x3

# Current player
current_player = (leader + trick_len) % 4
current_team = current_player % 2  # 0 or 1
```

### Notes for Neural Network Training

1. **Declaration is implicit**: Each file is for one (seed, declaration) pair. Include decl_id as an input feature.

2. **Local → Global mapping**: To get actual domino identities, use `deal_from_seed(seed)` from `scripts/solver2/rng.py`.

3. **All game tree states included**: Data includes root states, intermediate trick states, and near-terminal states.

4. **Balanced perspective**: V is from Team 0's perspective. For team-agnostic training, negate V when Team 1 is to play.

## Cross-Validation

The Python oracle rules (`forge/oracle/`) are validated against the TypeScript game engine (`src/game/`) using the scripts in `scratch/cross-validate/`.

### Table Comparison

Exhaustive comparison of lookup tables between Python and TypeScript:

```bash
# Export tables from both implementations
npx tsx scratch/cross-validate/export-ts-tables.ts
python scratch/cross-validate/export_py_tables.py

# Compare (5,000+ entries)
npx tsx scratch/cross-validate/compare-tables.ts
```

**Tables verified:**
| Table | Size | Purpose |
|-------|------|---------|
| effectiveSuit | 28×9 | What suit does each domino lead? |
| suitMask | 9×8 | Which dominoes can follow each suit? |
| hasPower | 28×9 | Is each domino trump for each config? |
| ranks | 10×8×28 | Trick ranking for each domino |
| canFollow | 10×8×28 | Follow-suit legality |
| ledSuit | 10×28 | Led suit when each domino leads |

### Trick Resolution

Tests that both implementations agree on trick winners:

```bash
npx tsx scratch/cross-validate/test-trick-resolution.ts
```

Samples tricks across all 10 declaration types and verifies winner/points match.

### Parquet Spot-Check

Validates deserialized oracle output for self-consistency:

```bash
# Quick check (5 files, 500 samples each)
python scratch/cross-validate/spot-check-oracle.py --files 5 --samples 500

# Thorough check
python scratch/cross-validate/spot-check-oracle.py --files 30 --samples 1000 --verbose
```

**Validations performed:**

| Check | What it verifies |
|-------|------------------|
| **Structural** | trick_len ∈ [0,3], play indices ∈ [0,7], V ∈ [-42,42], q ∈ {-128} ∪ [-42,42] |
| **Semantic** | Optimal Q-value equals V (max for team 0, min for team 1) |
| **Playthrough** | Following optimal moves leads to states that exist in the table |

### Declaration ID Mapping

The Python oracle uses a single `decl_id` while TypeScript uses separate `absorptionId` and `powerId`:

| Python decl_id | Name | TS absorptionId | TS powerId |
|----------------|------|-----------------|------------|
| 0-6 | pip trump | 0-6 | 0-6 |
| 7 | doubles-trump | 7 | 7 |
| 8 | doubles-suit | 7 | 8 |
| 9 | no-trump | 8 | 8 |
